//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from D:\Documents\Repos\sungaila\Cdelta\src\Grammar\Language\CdeltaParser.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Cdelta.Language
{
    using Antlr4.Runtime;
    using Antlr4.Runtime.Atn;
    using Antlr4.Runtime.Misc;
    using Antlr4.Runtime.Tree;
    using System.Collections.Generic;
    using DFA = Antlr4.Runtime.Dfa.DFA;

    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
    [System.CLSCompliant(false)]
    internal partial class CdeltaParser : Parser
    {
        public const int
            AUTOMATON = 1, STATE = 2, TRANSITION = 3, START = 4, END = 5, ENTER = 6, EXIT = 7, CONDITION = 8,
            SEMICOLON = 9, CURLY_OPEN = 10, CURLY_CLOSE = 11, LESS_THAN = 12, GREATER_THAN = 13,
            NAMESPACE = 14, DOT = 15, PUBLIC = 16, INTERNAL = 17, PROTECTED = 18, PRIVATE = 19,
            PARTIAL = 20, SINGLE_LINE_COMMENT = 21, DELIMITED_COMMENT = 22, WHITESPACES = 23,
            IDENTIFIER = 24;
        public const int
            RULE_codeFile = 0, RULE_namespace = 1, RULE_automatonDefinition = 2, RULE_accessModifier = 3,
            RULE_automatonDataType = 4, RULE_automatonBody = 5, RULE_stateDefinition = 6,
            RULE_stateInnerBlock = 7, RULE_stateEnter = 8, RULE_stateExit = 9, RULE_transitionDefinition = 10,
            RULE_transitionInnerBlock = 11, RULE_transitionEnter = 12;
        public static readonly string[] ruleNames = {
        "codeFile", "namespace", "automatonDefinition", "accessModifier", "automatonDataType",
        "automatonBody", "stateDefinition", "stateInnerBlock", "stateEnter", "stateExit",
        "transitionDefinition", "transitionInnerBlock", "transitionEnter"
    };

        private static readonly string[] _LiteralNames = {
        null, "'automaton'", "'state'", "'transition'", "'start'", "'end'", "'enter'",
        "'exit'", "'condition'", "';'", "'{'", "'}'", "'<'", "'>'", "'namespace'",
        "'.'", "'public'", "'internal'", "'protected'", "'private'", "'partial'"
    };
        private static readonly string[] _SymbolicNames = {
        null, "AUTOMATON", "STATE", "TRANSITION", "START", "END", "ENTER", "EXIT",
        "CONDITION", "SEMICOLON", "CURLY_OPEN", "CURLY_CLOSE", "LESS_THAN", "GREATER_THAN",
        "NAMESPACE", "DOT", "PUBLIC", "INTERNAL", "PROTECTED", "PRIVATE", "PARTIAL",
        "SINGLE_LINE_COMMENT", "DELIMITED_COMMENT", "WHITESPACES", "IDENTIFIER"
    };
        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [System.Obsolete("Use Vocabulary instead.")]
        public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

        private static string[] GenerateTokenNames(IVocabulary vocabulary, int length)
        {
            string[] tokenNames = new string[length];
            for (int i = 0; i < tokenNames.Length; i++)
            {
                tokenNames[i] = vocabulary.GetLiteralName(i);
                if (tokenNames[i] == null)
                {
                    tokenNames[i] = vocabulary.GetSymbolicName(i);
                }

                if (tokenNames[i] == null)
                {
                    tokenNames[i] = "<INVALID>";
                }
            }

            return tokenNames;
        }

        [System.Obsolete("Use IRecognizer.Vocabulary instead.")]
        public override string[] TokenNames
        {
            get
            {
                return tokenNames;
            }
        }

        [NotNull]
        public override IVocabulary Vocabulary
        {
            get
            {
                return DefaultVocabulary;
            }
        }

        public override string GrammarFileName { get { return "CdeltaParser.g4"; } }

        public override string[] RuleNames { get { return ruleNames; } }

        public override string SerializedAtn { get { return _serializedATN; } }

        public CdeltaParser(ITokenStream input)
            : base(input)
        {
            _interp = new ParserATNSimulator(this, _ATN);
        }
        public partial class CodeFileContext : ParserRuleContext
        {
            public NamespaceContext @namespace()
            {
                return GetRuleContext<NamespaceContext>(0);
            }
            public ITerminalNode Eof() { return GetToken(CdeltaParser.Eof, 0); }
            public CodeFileContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_codeFile; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterCodeFile(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitCodeFile(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitCodeFile(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public CodeFileContext codeFile()
        {
            CodeFileContext _localctx = new CodeFileContext(_ctx, State);
            EnterRule(_localctx, 0, RULE_codeFile);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 26; @namespace();
                    State = 27; Match(Eof);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class NamespaceContext : ParserRuleContext
        {
            public ITerminalNode NAMESPACE() { return GetToken(CdeltaParser.NAMESPACE, 0); }
            public ITerminalNode[] IDENTIFIER() { return GetTokens(CdeltaParser.IDENTIFIER); }
            public ITerminalNode IDENTIFIER(int i)
            {
                return GetToken(CdeltaParser.IDENTIFIER, i);
            }
            public ITerminalNode CURLY_OPEN() { return GetToken(CdeltaParser.CURLY_OPEN, 0); }
            public AutomatonDefinitionContext[] automatonDefinition()
            {
                return GetRuleContexts<AutomatonDefinitionContext>();
            }
            public AutomatonDefinitionContext automatonDefinition(int i)
            {
                return GetRuleContext<AutomatonDefinitionContext>(i);
            }
            public ITerminalNode CURLY_CLOSE() { return GetToken(CdeltaParser.CURLY_CLOSE, 0); }
            public ITerminalNode[] DOT() { return GetTokens(CdeltaParser.DOT); }
            public ITerminalNode DOT(int i)
            {
                return GetToken(CdeltaParser.DOT, i);
            }
            public NamespaceContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_namespace; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterNamespace(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitNamespace(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitNamespace(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public NamespaceContext @namespace()
        {
            NamespaceContext _localctx = new NamespaceContext(_ctx, State);
            EnterRule(_localctx, 2, RULE_namespace);
            int _la;
            try
            {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 29; Match(NAMESPACE);
                    State = 30; Match(IDENTIFIER);
                    State = 35;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    while (_la == DOT)
                    {
                        {
                            {
                                State = 31; Match(DOT);
                                State = 32; Match(IDENTIFIER);
                            }
                        }
                        State = 37;
                        _errHandler.Sync(this);
                        _la = _input.La(1);
                    }
                    State = 38; Match(CURLY_OPEN);
                    State = 39; automatonDefinition();
                    State = 43;
                    _errHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(_input, 1, _ctx);
                    while (_alt != 1 && _alt != global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber)
                    {
                        if (_alt == 1 + 1)
                        {
                            {
                                {
                                    State = 40; automatonDefinition();
                                }
                            }
                        }
                        State = 45;
                        _errHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(_input, 1, _ctx);
                    }
                    State = 46; Match(CURLY_CLOSE);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AutomatonDefinitionContext : ParserRuleContext
        {
            public ITerminalNode AUTOMATON() { return GetToken(CdeltaParser.AUTOMATON, 0); }
            public ITerminalNode IDENTIFIER() { return GetToken(CdeltaParser.IDENTIFIER, 0); }
            public ITerminalNode CURLY_OPEN() { return GetToken(CdeltaParser.CURLY_OPEN, 0); }
            public AutomatonBodyContext automatonBody()
            {
                return GetRuleContext<AutomatonBodyContext>(0);
            }
            public ITerminalNode CURLY_CLOSE() { return GetToken(CdeltaParser.CURLY_CLOSE, 0); }
            public AccessModifierContext accessModifier()
            {
                return GetRuleContext<AccessModifierContext>(0);
            }
            public ITerminalNode PARTIAL() { return GetToken(CdeltaParser.PARTIAL, 0); }
            public ITerminalNode LESS_THAN() { return GetToken(CdeltaParser.LESS_THAN, 0); }
            public AutomatonDataTypeContext automatonDataType()
            {
                return GetRuleContext<AutomatonDataTypeContext>(0);
            }
            public ITerminalNode GREATER_THAN() { return GetToken(CdeltaParser.GREATER_THAN, 0); }
            public AutomatonDefinitionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_automatonDefinition; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterAutomatonDefinition(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitAutomatonDefinition(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAutomatonDefinition(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AutomatonDefinitionContext automatonDefinition()
        {
            AutomatonDefinitionContext _localctx = new AutomatonDefinitionContext(_ctx, State);
            EnterRule(_localctx, 4, RULE_automatonDefinition);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 49;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PUBLIC) | (1L << INTERNAL) | (1L << PROTECTED) | (1L << PRIVATE))) != 0))
                    {
                        {
                            State = 48; accessModifier();
                        }
                    }

                    State = 52;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if (_la == PARTIAL)
                    {
                        {
                            State = 51; Match(PARTIAL);
                        }
                    }

                    State = 54; Match(AUTOMATON);
                    State = 55; Match(IDENTIFIER);
                    State = 60;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if (_la == LESS_THAN)
                    {
                        {
                            State = 56; Match(LESS_THAN);
                            State = 57; automatonDataType();
                            State = 58; Match(GREATER_THAN);
                        }
                    }

                    State = 62; Match(CURLY_OPEN);
                    State = 63; automatonBody();
                    State = 64; Match(CURLY_CLOSE);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AccessModifierContext : ParserRuleContext
        {
            public ITerminalNode PROTECTED() { return GetToken(CdeltaParser.PROTECTED, 0); }
            public ITerminalNode INTERNAL() { return GetToken(CdeltaParser.INTERNAL, 0); }
            public ITerminalNode PRIVATE() { return GetToken(CdeltaParser.PRIVATE, 0); }
            public ITerminalNode PUBLIC() { return GetToken(CdeltaParser.PUBLIC, 0); }
            public AccessModifierContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_accessModifier; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterAccessModifier(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitAccessModifier(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAccessModifier(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AccessModifierContext accessModifier()
        {
            AccessModifierContext _localctx = new AccessModifierContext(_ctx, State);
            EnterRule(_localctx, 6, RULE_accessModifier);
            try
            {
                State = 74;
                _errHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(_input, 5, _ctx))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 66; Match(PROTECTED);
                            State = 67; Match(INTERNAL);
                        }
                        break;

                    case 2:
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 68; Match(PRIVATE);
                            State = 69; Match(PROTECTED);
                        }
                        break;

                    case 3:
                        EnterOuterAlt(_localctx, 3);
                        {
                            State = 70; Match(PUBLIC);
                        }
                        break;

                    case 4:
                        EnterOuterAlt(_localctx, 4);
                        {
                            State = 71; Match(INTERNAL);
                        }
                        break;

                    case 5:
                        EnterOuterAlt(_localctx, 5);
                        {
                            State = 72; Match(PROTECTED);
                        }
                        break;

                    case 6:
                        EnterOuterAlt(_localctx, 6);
                        {
                            State = 73; Match(PRIVATE);
                        }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AutomatonDataTypeContext : ParserRuleContext
        {
            public ITerminalNode[] GREATER_THAN() { return GetTokens(CdeltaParser.GREATER_THAN); }
            public ITerminalNode GREATER_THAN(int i)
            {
                return GetToken(CdeltaParser.GREATER_THAN, i);
            }
            public AutomatonDataTypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_automatonDataType; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterAutomatonDataType(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitAutomatonDataType(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAutomatonDataType(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AutomatonDataTypeContext automatonDataType()
        {
            AutomatonDataTypeContext _localctx = new AutomatonDataTypeContext(_ctx, State);
            EnterRule(_localctx, 8, RULE_automatonDataType);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 77;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    do
                    {
                        {
                            {
                                State = 76;
                                _la = _input.La(1);
                                if (_la <= 0 || (_la == GREATER_THAN))
                                {
                                    _errHandler.RecoverInline(this);
                                }
                                else
                                {
                                    if (_input.La(1) == TokenConstants.Eof)
                                    {
                                        matchedEOF = true;
                                    }

                                    _errHandler.ReportMatch(this);
                                    Consume();
                                }
                            }
                        }
                        State = 79;
                        _errHandler.Sync(this);
                        _la = _input.La(1);
                    } while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << AUTOMATON) | (1L << STATE) | (1L << TRANSITION) | (1L << START) | (1L << END) | (1L << ENTER) | (1L << EXIT) | (1L << CONDITION) | (1L << SEMICOLON) | (1L << CURLY_OPEN) | (1L << CURLY_CLOSE) | (1L << LESS_THAN) | (1L << NAMESPACE) | (1L << DOT) | (1L << PUBLIC) | (1L << INTERNAL) | (1L << PROTECTED) | (1L << PRIVATE) | (1L << PARTIAL) | (1L << SINGLE_LINE_COMMENT) | (1L << DELIMITED_COMMENT) | (1L << WHITESPACES) | (1L << IDENTIFIER))) != 0));
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AutomatonBodyContext : ParserRuleContext
        {
            public StateDefinitionContext[] stateDefinition()
            {
                return GetRuleContexts<StateDefinitionContext>();
            }
            public StateDefinitionContext stateDefinition(int i)
            {
                return GetRuleContext<StateDefinitionContext>(i);
            }
            public TransitionDefinitionContext[] transitionDefinition()
            {
                return GetRuleContexts<TransitionDefinitionContext>();
            }
            public TransitionDefinitionContext transitionDefinition(int i)
            {
                return GetRuleContext<TransitionDefinitionContext>(i);
            }
            public AutomatonBodyContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_automatonBody; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterAutomatonBody(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitAutomatonBody(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAutomatonBody(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AutomatonBodyContext automatonBody()
        {
            AutomatonBodyContext _localctx = new AutomatonBodyContext(_ctx, State);
            EnterRule(_localctx, 10, RULE_automatonBody);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 85;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << STATE) | (1L << TRANSITION) | (1L << START) | (1L << END))) != 0))
                    {
                        {
                            State = 83;
                            _errHandler.Sync(this);
                            switch (_input.La(1))
                            {
                                case STATE:
                                case START:
                                case END:
                                    {
                                        State = 81; stateDefinition();
                                    }
                                    break;
                                case TRANSITION:
                                    {
                                        State = 82; transitionDefinition();
                                    }
                                    break;
                                default:
                                    throw new NoViableAltException(this);
                            }
                        }
                        State = 87;
                        _errHandler.Sync(this);
                        _la = _input.La(1);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class StateDefinitionContext : ParserRuleContext
        {
            public ITerminalNode STATE() { return GetToken(CdeltaParser.STATE, 0); }
            public ITerminalNode IDENTIFIER() { return GetToken(CdeltaParser.IDENTIFIER, 0); }
            public ITerminalNode SEMICOLON() { return GetToken(CdeltaParser.SEMICOLON, 0); }
            public ITerminalNode START() { return GetToken(CdeltaParser.START, 0); }
            public ITerminalNode END() { return GetToken(CdeltaParser.END, 0); }
            public ITerminalNode CURLY_OPEN() { return GetToken(CdeltaParser.CURLY_OPEN, 0); }
            public StateInnerBlockContext stateInnerBlock()
            {
                return GetRuleContext<StateInnerBlockContext>(0);
            }
            public ITerminalNode CURLY_CLOSE() { return GetToken(CdeltaParser.CURLY_CLOSE, 0); }
            public StateDefinitionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_stateDefinition; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterStateDefinition(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitStateDefinition(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitStateDefinition(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public StateDefinitionContext stateDefinition()
        {
            StateDefinitionContext _localctx = new StateDefinitionContext(_ctx, State);
            EnterRule(_localctx, 12, RULE_stateDefinition);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 89;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if (_la == START)
                    {
                        {
                            State = 88; Match(START);
                        }
                    }

                    State = 92;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if (_la == END)
                    {
                        {
                            State = 91; Match(END);
                        }
                    }

                    State = 94; Match(STATE);
                    State = 95; Match(IDENTIFIER);
                    State = 101;
                    _errHandler.Sync(this);
                    switch (_input.La(1))
                    {
                        case SEMICOLON:
                            {
                                State = 96; Match(SEMICOLON);
                            }
                            break;
                        case CURLY_OPEN:
                            {
                                {
                                    State = 97; Match(CURLY_OPEN);
                                    State = 98; stateInnerBlock();
                                    State = 99; Match(CURLY_CLOSE);
                                }
                            }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class StateInnerBlockContext : ParserRuleContext
        {
            public StateEnterContext stateEnter()
            {
                return GetRuleContext<StateEnterContext>(0);
            }
            public StateExitContext stateExit()
            {
                return GetRuleContext<StateExitContext>(0);
            }
            public StateInnerBlockContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_stateInnerBlock; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterStateInnerBlock(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitStateInnerBlock(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitStateInnerBlock(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public StateInnerBlockContext stateInnerBlock()
        {
            StateInnerBlockContext _localctx = new StateInnerBlockContext(_ctx, State);
            EnterRule(_localctx, 14, RULE_stateInnerBlock);
            int _la;
            try
            {
                State = 115;
                _errHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(_input, 16, _ctx))
                {
                    case 1:
                        EnterOuterAlt(_localctx, 1);
                        {
                            State = 104;
                            _errHandler.Sync(this);
                            _la = _input.La(1);
                            if (_la == ENTER)
                            {
                                {
                                    State = 103; stateEnter();
                                }
                            }

                            State = 107;
                            _errHandler.Sync(this);
                            _la = _input.La(1);
                            if (_la == EXIT)
                            {
                                {
                                    State = 106; stateExit();
                                }
                            }

                        }
                        break;

                    case 2:
                        EnterOuterAlt(_localctx, 2);
                        {
                            State = 110;
                            _errHandler.Sync(this);
                            _la = _input.La(1);
                            if (_la == EXIT)
                            {
                                {
                                    State = 109; stateExit();
                                }
                            }

                            State = 113;
                            _errHandler.Sync(this);
                            _la = _input.La(1);
                            if (_la == ENTER)
                            {
                                {
                                    State = 112; stateEnter();
                                }
                            }

                        }
                        break;
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class StateEnterContext : ParserRuleContext
        {
            public ITerminalNode ENTER() { return GetToken(CdeltaParser.ENTER, 0); }
            public ITerminalNode SEMICOLON() { return GetToken(CdeltaParser.SEMICOLON, 0); }
            public StateEnterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_stateEnter; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterStateEnter(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitStateEnter(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitStateEnter(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public StateEnterContext stateEnter()
        {
            StateEnterContext _localctx = new StateEnterContext(_ctx, State);
            EnterRule(_localctx, 16, RULE_stateEnter);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 117; Match(ENTER);
                    State = 118; Match(SEMICOLON);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class StateExitContext : ParserRuleContext
        {
            public ITerminalNode EXIT() { return GetToken(CdeltaParser.EXIT, 0); }
            public ITerminalNode SEMICOLON() { return GetToken(CdeltaParser.SEMICOLON, 0); }
            public StateExitContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_stateExit; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterStateExit(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitStateExit(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitStateExit(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public StateExitContext stateExit()
        {
            StateExitContext _localctx = new StateExitContext(_ctx, State);
            EnterRule(_localctx, 18, RULE_stateExit);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 120; Match(EXIT);
                    State = 121; Match(SEMICOLON);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class TransitionDefinitionContext : ParserRuleContext
        {
            public ITerminalNode TRANSITION() { return GetToken(CdeltaParser.TRANSITION, 0); }
            public ITerminalNode[] IDENTIFIER() { return GetTokens(CdeltaParser.IDENTIFIER); }
            public ITerminalNode IDENTIFIER(int i)
            {
                return GetToken(CdeltaParser.IDENTIFIER, i);
            }
            public ITerminalNode SEMICOLON() { return GetToken(CdeltaParser.SEMICOLON, 0); }
            public ITerminalNode CURLY_OPEN() { return GetToken(CdeltaParser.CURLY_OPEN, 0); }
            public TransitionInnerBlockContext transitionInnerBlock()
            {
                return GetRuleContext<TransitionInnerBlockContext>(0);
            }
            public ITerminalNode CURLY_CLOSE() { return GetToken(CdeltaParser.CURLY_CLOSE, 0); }
            public TransitionDefinitionContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_transitionDefinition; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterTransitionDefinition(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitTransitionDefinition(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitTransitionDefinition(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public TransitionDefinitionContext transitionDefinition()
        {
            TransitionDefinitionContext _localctx = new TransitionDefinitionContext(_ctx, State);
            EnterRule(_localctx, 20, RULE_transitionDefinition);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 123; Match(TRANSITION);
                    State = 124; Match(IDENTIFIER);
                    State = 125; Match(IDENTIFIER);
                    State = 131;
                    _errHandler.Sync(this);
                    switch (_input.La(1))
                    {
                        case SEMICOLON:
                            {
                                State = 126; Match(SEMICOLON);
                            }
                            break;
                        case CURLY_OPEN:
                            {
                                {
                                    State = 127; Match(CURLY_OPEN);
                                    State = 128; transitionInnerBlock();
                                    State = 129; Match(CURLY_CLOSE);
                                }
                            }
                            break;
                        default:
                            throw new NoViableAltException(this);
                    }
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class TransitionInnerBlockContext : ParserRuleContext
        {
            public TransitionEnterContext transitionEnter()
            {
                return GetRuleContext<TransitionEnterContext>(0);
            }
            public TransitionInnerBlockContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_transitionInnerBlock; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterTransitionInnerBlock(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitTransitionInnerBlock(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitTransitionInnerBlock(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public TransitionInnerBlockContext transitionInnerBlock()
        {
            TransitionInnerBlockContext _localctx = new TransitionInnerBlockContext(_ctx, State);
            EnterRule(_localctx, 22, RULE_transitionInnerBlock);
            int _la;
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 134;
                    _errHandler.Sync(this);
                    _la = _input.La(1);
                    if (_la == ENTER)
                    {
                        {
                            State = 133; transitionEnter();
                        }
                    }

                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public partial class TransitionEnterContext : ParserRuleContext
        {
            public ITerminalNode ENTER() { return GetToken(CdeltaParser.ENTER, 0); }
            public ITerminalNode SEMICOLON() { return GetToken(CdeltaParser.SEMICOLON, 0); }
            public TransitionEnterContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_transitionEnter; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.EnterTransitionEnter(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                ICdeltaParserListener typedListener = listener as ICdeltaParserListener;
                if (typedListener != null) typedListener.ExitTransitionEnter(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                ICdeltaParserVisitor<TResult> typedVisitor = visitor as ICdeltaParserVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitTransitionEnter(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public TransitionEnterContext transitionEnter()
        {
            TransitionEnterContext _localctx = new TransitionEnterContext(_ctx, State);
            EnterRule(_localctx, 24, RULE_transitionEnter);
            try
            {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 136; Match(ENTER);
                    State = 137; Match(SEMICOLON);
                }
            }
            catch (RecognitionException re)
            {
                _localctx.exception = re;
                _errHandler.ReportError(this, re);
                _errHandler.Recover(this, re);
            }
            finally
            {
                ExitRule();
            }
            return _localctx;
        }

        public static readonly string _serializedATN =
            "\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x1A\x8E\x4\x2\t" +
            "\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t" +
            "\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x3\x2\x3\x2\x3\x2" +
            "\x3\x3\x3\x3\x3\x3\x3\x3\a\x3$\n\x3\f\x3\xE\x3\'\v\x3\x3\x3\x3\x3\x3\x3" +
            "\a\x3,\n\x3\f\x3\xE\x3/\v\x3\x3\x3\x3\x3\x3\x4\x5\x4\x34\n\x4\x3\x4\x5" +
            "\x4\x37\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4?\n\x4\x3\x4\x3" +
            "\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5" +
            "M\n\x5\x3\x6\x6\x6P\n\x6\r\x6\xE\x6Q\x3\a\x3\a\a\aV\n\a\f\a\xE\aY\v\a" +
            "\x3\b\x5\b\\\n\b\x3\b\x5\b_\n\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x3\b\x5" +
            "\bh\n\b\x3\t\x5\tk\n\t\x3\t\x5\tn\n\t\x3\t\x5\tq\n\t\x3\t\x5\tt\n\t\x5" +
            "\tv\n\t\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3" +
            "\f\x3\f\x5\f\x86\n\f\x3\r\x5\r\x89\n\r\x3\xE\x3\xE\x3\xE\x3\xE\x3-\x2" +
            "\x2\xF\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16" +
            "\x2\x18\x2\x1A\x2\x2\x3\x3\x2\xF\xF\x97\x2\x1C\x3\x2\x2\x2\x4\x1F\x3\x2" +
            "\x2\x2\x6\x33\x3\x2\x2\x2\bL\x3\x2\x2\x2\nO\x3\x2\x2\x2\fW\x3\x2\x2\x2" +
            "\xE[\x3\x2\x2\x2\x10u\x3\x2\x2\x2\x12w\x3\x2\x2\x2\x14z\x3\x2\x2\x2\x16" +
            "}\x3\x2\x2\x2\x18\x88\x3\x2\x2\x2\x1A\x8A\x3\x2\x2\x2\x1C\x1D\x5\x4\x3" +
            "\x2\x1D\x1E\a\x2\x2\x3\x1E\x3\x3\x2\x2\x2\x1F \a\x10\x2\x2 %\a\x1A\x2" +
            "\x2!\"\a\x11\x2\x2\"$\a\x1A\x2\x2#!\x3\x2\x2\x2$\'\x3\x2\x2\x2%#\x3\x2" +
            "\x2\x2%&\x3\x2\x2\x2&(\x3\x2\x2\x2\'%\x3\x2\x2\x2()\a\f\x2\x2)-\x5\x6" +
            "\x4\x2*,\x5\x6\x4\x2+*\x3\x2\x2\x2,/\x3\x2\x2\x2-.\x3\x2\x2\x2-+\x3\x2" +
            "\x2\x2.\x30\x3\x2\x2\x2/-\x3\x2\x2\x2\x30\x31\a\r\x2\x2\x31\x5\x3\x2\x2" +
            "\x2\x32\x34\x5\b\x5\x2\x33\x32\x3\x2\x2\x2\x33\x34\x3\x2\x2\x2\x34\x36" +
            "\x3\x2\x2\x2\x35\x37\a\x16\x2\x2\x36\x35\x3\x2\x2\x2\x36\x37\x3\x2\x2" +
            "\x2\x37\x38\x3\x2\x2\x2\x38\x39\a\x3\x2\x2\x39>\a\x1A\x2\x2:;\a\xE\x2" +
            "\x2;<\x5\n\x6\x2<=\a\xF\x2\x2=?\x3\x2\x2\x2>:\x3\x2\x2\x2>?\x3\x2\x2\x2" +
            "?@\x3\x2\x2\x2@\x41\a\f\x2\x2\x41\x42\x5\f\a\x2\x42\x43\a\r\x2\x2\x43" +
            "\a\x3\x2\x2\x2\x44\x45\a\x14\x2\x2\x45M\a\x13\x2\x2\x46G\a\x15\x2\x2G" +
            "M\a\x14\x2\x2HM\a\x12\x2\x2IM\a\x13\x2\x2JM\a\x14\x2\x2KM\a\x15\x2\x2" +
            "L\x44\x3\x2\x2\x2L\x46\x3\x2\x2\x2LH\x3\x2\x2\x2LI\x3\x2\x2\x2LJ\x3\x2" +
            "\x2\x2LK\x3\x2\x2\x2M\t\x3\x2\x2\x2NP\n\x2\x2\x2ON\x3\x2\x2\x2PQ\x3\x2" +
            "\x2\x2QO\x3\x2\x2\x2QR\x3\x2\x2\x2R\v\x3\x2\x2\x2SV\x5\xE\b\x2TV\x5\x16" +
            "\f\x2US\x3\x2\x2\x2UT\x3\x2\x2\x2VY\x3\x2\x2\x2WU\x3\x2\x2\x2WX\x3\x2" +
            "\x2\x2X\r\x3\x2\x2\x2YW\x3\x2\x2\x2Z\\\a\x6\x2\x2[Z\x3\x2\x2\x2[\\\x3" +
            "\x2\x2\x2\\^\x3\x2\x2\x2]_\a\a\x2\x2^]\x3\x2\x2\x2^_\x3\x2\x2\x2_`\x3" +
            "\x2\x2\x2`\x61\a\x4\x2\x2\x61g\a\x1A\x2\x2\x62h\a\v\x2\x2\x63\x64\a\f" +
            "\x2\x2\x64\x65\x5\x10\t\x2\x65\x66\a\r\x2\x2\x66h\x3\x2\x2\x2g\x62\x3" +
            "\x2\x2\x2g\x63\x3\x2\x2\x2h\xF\x3\x2\x2\x2ik\x5\x12\n\x2ji\x3\x2\x2\x2" +
            "jk\x3\x2\x2\x2km\x3\x2\x2\x2ln\x5\x14\v\x2ml\x3\x2\x2\x2mn\x3\x2\x2\x2" +
            "nv\x3\x2\x2\x2oq\x5\x14\v\x2po\x3\x2\x2\x2pq\x3\x2\x2\x2qs\x3\x2\x2\x2" +
            "rt\x5\x12\n\x2sr\x3\x2\x2\x2st\x3\x2\x2\x2tv\x3\x2\x2\x2uj\x3\x2\x2\x2" +
            "up\x3\x2\x2\x2v\x11\x3\x2\x2\x2wx\a\b\x2\x2xy\a\v\x2\x2y\x13\x3\x2\x2" +
            "\x2z{\a\t\x2\x2{|\a\v\x2\x2|\x15\x3\x2\x2\x2}~\a\x5\x2\x2~\x7F\a\x1A\x2" +
            "\x2\x7F\x85\a\x1A\x2\x2\x80\x86\a\v\x2\x2\x81\x82\a\f\x2\x2\x82\x83\x5" +
            "\x18\r\x2\x83\x84\a\r\x2\x2\x84\x86\x3\x2\x2\x2\x85\x80\x3\x2\x2\x2\x85" +
            "\x81\x3\x2\x2\x2\x86\x17\x3\x2\x2\x2\x87\x89\x5\x1A\xE\x2\x88\x87\x3\x2" +
            "\x2\x2\x88\x89\x3\x2\x2\x2\x89\x19\x3\x2\x2\x2\x8A\x8B\a\b\x2\x2\x8B\x8C" +
            "\a\v\x2\x2\x8C\x1B\x3\x2\x2\x2\x15%-\x33\x36>LQUW[^gjmpsu\x85\x88";
        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
    }
} // namespace Cdelta.Language
